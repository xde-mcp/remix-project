<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Select Test</title>
    <style>
      /* Leave space at bottom for sticky log panel */
      :root { --log-height: 28vh; }
      body { font-family: ui-sans-serif, system-ui, sans-serif; margin: 1.5rem; padding-bottom: calc(var(--log-height) + 1rem); }
      header { display: flex; gap: 1rem; align-items: center; }
      .row { display: flex; gap: 0.5rem; align-items: center; }
      input[type=text]{ padding: .4rem .6rem; width: 320px; }
      button { padding: .4rem .7rem; cursor: pointer; }
      table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
      th, td { border-bottom: 1px solid #ddd; padding: .4rem .6rem; text-align: left; }
      tr:hover { background: #fafafa; }
      .badge { font-size: .8rem; padding: .1rem .35rem; border: 1px solid #ccc; border-radius: .35rem; }
      .ok { color: #0a0; }
      .warn { color: #b80; }
      .err { color: #a00; }

      /* Sticky log panel */
      #log {
        position: fixed;
        left: 0; right: 0; bottom: 0;
        height: var(--log-height);
        margin: 0; padding: 0.75rem 1rem;
        background: #101010; color: #e8e8e8;
        border-top: 1px solid #333;
        overflow: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        white-space: pre-wrap;
        z-index: 1000;
      }
      #log::before { content: 'Log'; display: block; color: #9aa0a6; font-size: 12px; letter-spacing: .06em; text-transform: uppercase; margin-bottom: .25rem; }
    </style>
  </head>
  <body>
    <header>
      <h2>Select & Run a Test</h2>
      <span id="status" class="badge">Loading…</span>
    </header>
    <div class="row">
      <label>Filter:</label>
      <input id="filter" type="text" placeholder="type to filter by name"/>
      <label>Mode:</label>
      <select id="mode">
        <option value="local">Local</option>
        <option value="remote">CircleCI</option>
      </select>
      <label>Browser:</label>
      <select id="browser">
        <option value="chrome">chrome</option>
        <option value="firefox">firefox</option>
      </select>
    </div>
    <table>
      <thead>
        <tr>
          <th>Test</th>
          <th>Source</th>
          <th>Dist</th>
          <th></th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  <pre id="log"></pre>

    <script>
      const $ = (s) => document.querySelector(s)
      const tbody = $('#tbody')
      const status = $('#status')
      const filter = $('#filter')
      const modeSel = $('#mode')
      const browserSel = $('#browser')
      const log = $('#log')
      let tests = []

      async function fetchStatus() {
        const r = await fetch('/api/status')
        const j = await r.json()
        const t = []
        t.push('branch: ' + j.branch)
        t.push('circle token: ' + (j.hasToken ? '✅' : '⚠️ missing'))
        status.textContent = t.join(' · ')
        status.className = 'badge ' + (j.hasToken ? 'ok' : 'warn')
      }

      function render() {
        const q = filter.value.toLowerCase()
        const rows = tests.filter(x => x.base.toLowerCase().includes(q)).map((t) => `
          <tr>
            <td><code>${t.base}</code></td>
            <td>${t.src.replace('apps/remix-ide-e2e/src/tests/','')}</td>
            <td>${t.hasDist ? '<span class="ok">built</span>' : '<span class="warn">missing</span>'}</td>
            <td><button data-test="${t.base}">Run</button></td>
          </tr>
        `)
        tbody.innerHTML = rows.join('')
        tbody.querySelectorAll('button[data-test]').forEach(btn => btn.onclick = (ev) => trigger(ev.target.dataset.test))
      }

      async function load() {
        await fetchStatus()
        const r = await fetch('/api/tests')
        const j = await r.json()
        tests = j.tests || []
        render()
      }

      async function trigger(name) {
        const mode = modeSel.value
        const browser = browserSel.value
        // Append instead of overwrite so we keep history
        const start = `\n> triggering ${name} (${mode})...\n`
        log.textContent += start
        log.scrollTop = log.scrollHeight
        const r = await fetch('/api/trigger', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode, test: name, browser }) })
        const j = await r.json()
        log.textContent += JSON.stringify(j, null, 2) + "\n"
        log.scrollTop = log.scrollHeight
        if (j.url) {
          const a = document.createElement('a')
          a.href = j.url
          a.textContent = 'open pipeline'
          a.target = '_blank'
          log.appendChild(document.createElement('br'))
          log.appendChild(a)
          log.appendChild(document.createElement('br'))
          log.scrollTop = log.scrollHeight
        }

        // If remote, start polling for CI status
        if (mode === 'remote' && j.pipelineId) {
          await pollCi(j.pipelineId)
        }
      }

      async function pollCi(pipelineId) {
        const pad = (s) => (s || 'unknown').toString().padEnd(10, ' ')
        const sleep = (ms) => new Promise(r => setTimeout(r, ms))
        log.textContent += `pipeline: ${pipelineId} -> fetching status...\n`
        log.scrollTop = log.scrollHeight
        let done = false
        while (!done) {
          try {
            const r = await fetch(`/api/ci-status?pipelineId=${encodeURIComponent(pipelineId)}`)
            const j = await r.json()
            if (!r.ok) throw new Error(j && j.details || 'status error')
            const wfLines = (j.workflows || []).map(wf => `  - ${wf.name}  ${pad(wf.status)}  (id ${wf.id})`).join('\n')
            const counts = j.summary && j.summary.counts ? JSON.stringify(j.summary.counts) : '{}'
            const ui = j.uiUrl ? `\n  ${j.uiUrl}\n` : '\n'
            log.textContent += `status: pipeline ${j.pipeline.number || ''} state=${j.pipeline.state} workflows=${counts}${ui}${wfLines}\n`
            log.scrollTop = log.scrollHeight
            done = Boolean(j.summary && j.summary.done)
            if (!done) await sleep(5000)
          } catch (e) {
            log.textContent += `status error: ${e.message}\n`
            log.scrollTop = log.scrollHeight
            await sleep(7000)
          }
        }
        log.textContent += `pipeline complete.\n`
        log.scrollTop = log.scrollHeight
      }

      filter.oninput = render
      load()
    </script>
  </body>
  </html>
